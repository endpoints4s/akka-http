{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Akka HTTP"},{"location":"/index.html#akka-http","text":"Client and server backed by Akka HTTP.\nWarning As explained in the section Mixed versioning is not allowed in the Akka documentation, you have to make sure that all the Akka modules of your application have the same version. For this reason, the interpreters akka-http-server and akka-http-client have marked their dependency to Akka as “provided”. As a consequence, to use these interpreters you will have to explicitly add a dependency on akka-stream: \"com.typesafe.akka\" %% \"akka-stream\" % \"<akka-version>\"\n Where <akka-version> is binary compatible and higher or equal to 2.6.17.","title":"Akka HTTP"},{"location":"/index.html#client","text":"API documentation","title":"Client"},{"location":"/index.html#endpoints4s-akkahttp-client-endpoints","text":"The Endpoints interpreter fixes the Endpoint[A, B] type to a function from A to Future[B]:\ncopysourcecase class Endpoint[A, B](\n    request: Request[A],\n    response: Response[B]\n) extends (A => Future[B])\nThis means that, given the following endpoint definition:\ncopysourceval someResource: Endpoint[Int, String] =\n  endpoint(get(path / \"some-resource\" / segment[Int]()), ok(textResponse))\nIt can be invoked as follows:\ncopysourceval eventuallyString: Future[String] = someResource(42)","title":"endpoints4s.akkahttp.client.Endpoints"},{"location":"/index.html#endpoints4s-akkahttp-client-chunkedentities","text":"The ChunkedEntities interpreter fixes the Chunks[A] type to akka.stream.scaladsl.Source[A, _]:\ncopysourcetype Chunks[A] = akka.stream.scaladsl.Source[A, _]\nThis means that, given the following endpoint definition:\ncopysourceval logo: Endpoint[Unit, Chunks[Array[Byte]]] =\n  endpoint(get(path / \"logo.png\"), ok(bytesChunksResponse))\nIt can be invoked as follows:\ncopysourceimport akka.stream.scaladsl.Source\n\nval bytesSource: Source[Array[Byte], _] =\n  Source.futureSource(logo(()))\n\nbytesSource.runForeach { bytes => println(s\"Received ${bytes.length} bytes\") }","title":"endpoints4s.akkahttp.client.ChunkedEntities"},{"location":"/index.html#server","text":"API documentation","title":"Server"},{"location":"/index.html#endpoints4s-akkahttp-server-endpoints","text":"The Endpoints interpreter fixes the Endpoint[A, B] type to something that, given an implementation function A => B, returns an akka.http.scaladsl.server.Route that can be integrated to your Akka HTTP application.\nFor instance, given the following endpoint definition:\ncopysourceval someResource: Endpoint[Int, String] =\n  endpoint(get(path / \"some-resource\" / segment[Int]()), ok(textResponse))\nIt can be implemented as follows:\ncopysourceval route: Route =\n  someResource.implementedBy(x => s\"Received $x\")\nAlternatively, there is also a method implementedByAsync that takes an implementing function returning a Future[B].","title":"endpoints4s.akkahttp.server.Endpoints"},{"location":"/index.html#endpoints4s-akkahttp-server-chunkedentities","text":"The ChunkedEntities interpreter fixes the Chunks[A] type to akka.stream.scaladsl.Source[A, _].\nFor instance, given the following chunked endpoint definition:\ncopysourceval logo: Endpoint[Unit, Chunks[Array[Byte]]] =\n  endpoint(get(path / \"logo.png\"), ok(bytesChunksResponse))\nIt can be implemented as follows:\ncopysourceimport java.nio.file.Paths\nimport akka.stream.scaladsl.FileIO\n\nval logoRoute: Route =\n  logo.implementedBy { _ =>\n    FileIO.fromPath(Paths.get(\"/foo/bar/logo.png\")).map(_.toArray)\n  }","title":"endpoints4s.akkahttp.server.ChunkedEntities"},{"location":"/index.html#error-handling","text":"When the server processes requests, three kinds of errors can happen: the incoming request doesn’t match any endpoint, the request does match an endpoint but is invalid (e.g. one parameter has a wrong type), or an exception is thrown.","title":"Error handling"},{"location":"/index.html#the-incoming-request-doesn-t-match-any-endpoint","text":"In that case, the routes constructed by endpoints4s can’t do anything. You have to deal with such errors in the usual Akka HTTP way: by using an implicit akka.http.scaladsl.server.RejectionHandler having a handleNotFound clause.","title":"The incoming request doesn’t match any endpoint"},{"location":"/index.html#the-incoming-request-is-invalid","text":"In that case, endpoints4s returns a “Bad Request” (400) response reporting all the errors in a JSON array. You can change this behavior by overriding the handleClientErrors method.","title":"The incoming request is invalid"},{"location":"/index.html#an-exception-is-thrown","text":"If an exception is thrown during request decoding, or when running the business logic, or when encoding the response, endpoints4s returns an “Internal Server Error” (500) response reporting the error in a JSON array. You can change this behavior by overriding the handleServerError method.","title":"An exception is thrown"}]}